diff --git a/newsfragments/607.bugfix b/newsfragments/607.bugfix
new file mode 100644
index 000000000..6fa543542
--- /dev/null
+++ b/newsfragments/607.bugfix
@@ -0,0 +1 @@
+Flumpy: Prefer to return ``flex.int`` instead of ``flex.long`` when these are the same size. This solves ambiguous behaviour when reading images on Windows platforms.
diff --git a/newsfragments/609.misc b/newsfragments/609.misc
new file mode 100644
index 000000000..3358d8186
--- /dev/null
+++ b/newsfragments/609.misc
@@ -0,0 +1 @@
+Fix case from #607 where we didn't properly handle casting uint with data loss.
diff --git a/src/dxtbx/boost_python/flumpy.cc b/src/dxtbx/boost_python/flumpy.cc
index 93fa30c87..a289f4acd 100644
--- a/src/dxtbx/boost_python/flumpy.cc
+++ b/src/dxtbx/boost_python/flumpy.cc
@@ -425,6 +425,9 @@ py::object from_numpy(py::object array) {
     return numpy_to_array_family<af::versa<bool, af::flex_grid<>>>(np_array);
   } else if (dtype == 'i') {
     return numpy_to_array_family<af::versa<int, af::flex_grid<>>>(np_array);
+  } else if (dtype == 'l' && (sizeof(long) == sizeof(int))) {
+    // In cases where int and long are degenerate (windows), prefer int
+    return numpy_to_array_family<af::versa<int, af::flex_grid<>>>(np_array);
   } else if (dtype == 'l') {
     return numpy_to_array_family<af::versa<long, af::flex_grid<>>>(np_array);
   } else if (dtype == 'f') {
diff --git a/src/dxtbx/nexus/__init__.py b/src/dxtbx/nexus/__init__.py
index 7c3076c95..ccd84a7ec 100644
--- a/src/dxtbx/nexus/__init__.py
+++ b/src/dxtbx/nexus/__init__.py
@@ -2,7 +2,7 @@
 
 import itertools
 import logging
-from typing import Optional, Tuple, cast
+from typing import Literal, Optional, Tuple, cast
 
 import h5py
 import numpy as np
@@ -486,31 +486,52 @@ def get_static_mask(nxdetector: nxmx.NXdetector) -> tuple[flex.bool, ...] | None
 
 def _dataset_as_flex(
     data: h5py.Dataset,
-    slices: tuple,
-    bit_depth: Optional[int] = None,
+    slices: tuple[slice, ...] | None,
+    bit_depth: Literal[32] | None = None,
 ) -> flex.float | flex.double | flex.int:
-    data_np = np.ascontiguousarray(data[slices])
-    np_float_types = (
-        np.half,
-        np.single,
-        np.float16,
-    )
-    if np.issubdtype(data_np.dtype, np.int64):
-        if bit_depth and bit_depth <= 32:
-            # bit_depth promises that we can safely convert to
-            # a 32-bit int without corrupting the data
-            data_np = data_np.astype(np.intc, copy=False)
+    """
+    Convert an HDF5 dataset to one of the expected flex types.
+
+    Args:
+        data: The HDF5 Dataset to convert
+        slices:
+            The Dataset will be sliced and made contiguous to this shape.
+        bit_depth:
+            If set to 32, and the dataset in signed integer
+            representation requires more than 32-bit, then the data will
+            be converted to a signed 32-bit integer. Without this, such
+            attempted conversions will raise a TypeError.
+    """
+    # Make a guaranteed-contiguous copy of the sliced data
+    data_np = np.ascontiguousarray(data[slices or ()])
+    dtype = data_np.dtype
+
+    # Handle integer conversion. Safe to convert if:
+    # - Is signed and <= 4 bytes
+    # - Is unsigned and <= 2 bytes
+    #
+    # Unsafe conversions to 32-bit integer can occur, but only if
+    # bit_depth is explicitly set to 32.
+    if np.issubdtype(dtype, np.integer):
+        if (
+            (np.issubdtype(dtype, np.signedinteger) and dtype.itemsize <= 4)
+            or (np.issubdtype(dtype, np.unsignedinteger) and dtype.itemsize <= 2)
+            or bit_depth == 32
+        ):
+            data_np = data_np.astype(np.int32, copy=False)
         else:
-            raise TypeError(f"Unsupported dtype {data_np.dtype}")
-    elif np.issubdtype(data_np.dtype, np.integer):
-        data_np = data_np.astype(np.intc, copy=False)
-    elif np.issubdtype(data_np.dtype, np.int32) or data_np.dtype in np_float_types:
-        data_np = data_np.astype(np.float32, copy=False)
-    elif not np.issubdtype(data_np.dtype, np.floating):
-        raise TypeError(f"Unsupported dtype {data_np.dtype}")
+            raise TypeError(f"Unsupported integer dtype {data_np.dtype}")
+    elif np.issubdtype(dtype, np.floating):
+        if dtype.itemsize <= 4:
+            # Promote anything <= single precision up to single precision
+            data_np = data_np.astype(np.float32, copy=False)
+        else:
+            # Otherwise, everything else becomes double
+            data_np = data_np.astype(np.float64, copy=False)
     else:
-        # assume double
-        data_np = data_np.astype(np.float64, copy=False)
+        # Isn't a recognised integer or floating point type
+        raise TypeError(f"Unsupported dtype {data_np.dtype}")
+
     data_flex = flumpy.from_numpy(data_np)
     return data_flex
 
diff --git a/tests/nexus/test_build_dxtbx_models.py b/tests/nexus/test_build_dxtbx_models.py
index 3ebacb806..8b3b684ac 100644
--- a/tests/nexus/test_build_dxtbx_models.py
+++ b/tests/nexus/test_build_dxtbx_models.py
@@ -680,7 +680,7 @@ def test_dataset_as_flex_int():
             assert isinstance(flex_a, flex.int)
             assert flex_a.all() == g[k].shape
             assert list(flex_a) == list(g[k])
-        with pytest.raises(TypeError, match="Unsupported dtype .*"):
+        with pytest.raises(TypeError, match="Unsupported integer dtype .*"):
             dxtbx.nexus._dataset_as_flex(g["int64"], slices)
         flex_a = dxtbx.nexus._dataset_as_flex(g["int64"], slices, bit_depth=32)
         assert isinstance(flex_a, flex.int)
diff --git a/tests/test_flumpy.py b/tests/test_flumpy.py
index a784e4a93..9598a193f 100644
--- a/tests/test_flumpy.py
+++ b/tests/test_flumpy.py
@@ -70,6 +70,9 @@ def flex_numeric(request):
     flex_typename = request.param
     if not hasattr(flex, flex_typename):
         pytest.skip(f"Type flex.{flex_typename} not available on this flex instance")
+    # Don't do long on windows, we prefer to get int
+    if flex_typename == "long" and np.dtype("l").itemsize == np.dtype("i").itemsize:
+        pytest.skip("On this platform, flex.long = flex.int so latter preferred")
     return getattr(flex, flex_typename)
 
 
@@ -350,3 +353,17 @@ def test_nonowning():
     assert f_a[2] == 9
     assert n_b[2] == 9
     assert f_c[1] == 9
+
+
+def test_int_long_degeneracy():
+    if np.dtype("l").itemsize != np.dtype("i").itemsize:
+        pytest.skip("Test only runs on platforms where int = long")
+    npo = np.array([240, 259, 144, 187]).astype("l")
+    fo = flumpy.from_numpy(npo)
+    assert isinstance(fo, flex.int)
+
+    assert fo.all() == npo.shape
+    assert all(fo[x] == npo[x] for x in range(4))
+    npo[0] = 42
+    assert all(fo[x] == npo[x] for x in range(4))
+    assert fo[0] == 42
